<?php include $_SERVER['DOCUMENT_ROOT'].'/MinsPipeline/php/articleTemplate_before.php' ?>
<?php $mpData=array('DDAline'); ?>

<h2>概述</h2>
<p>...</p>


<h2>数值微分法DDA</h2>
<p>
    数值微分法，Digital Differential Analyzer，简称DDA。这是一种直接从直线的微分方程生成直线的方法。
</p>
<p>
    通过给定直线的两端点坐标`P_0(x_0,y_0)`和`P_1(x_1,y_1)`，我们可以得到直线的微分方程：
</p>
<formula>`dy/dx=(Δy)/(Δx)=(y_1-y_0)/(x_1-x_0 )=k`</formula>
<p>这里的`△x=x_1-x_0`,`△y=y_1-y_0`</p>

<h3>DDA算法的原理是这样的：</h3>
<p>
    由于直线的一阶导数是连续的，而且对于`△x`和`△y`是成比例的。
    因此，可以通过在当前位置`(x_i,y_i)`上分别加上二个小增量`ε△x`和`ε△y`
    （`ε`为无穷小的正数）来求出下一点`(x_(i+1),y_(i+1))`的`x`,`y`坐标
</p>
<formula>`x_(i+1)=x_i+ε⋅Δx`</formula>
<formula>`y_(i+1)=y_i+ε⋅Δy`</formula>
<p>
    显然，这个方法在精度无限高的情况下可绘出无误差的直线。但设备的精度总是有限的，
    因此通常选择`ε=1/(max(|△x|,|△y|))`，
    这时`ε△x`或`ε△y`中会有一个变成单位步长，
    这样一来可以使得算法在最大位移方向上，每次总是走一步。
</p>
<p>
    这又可分为两种情况进行考虑：
</p>
    <li>
        一种是最大位移方向为`x`方向，也就是斜率绝对值小于1的情况。
        这时：`ε`为`|△x|`的倒数，在`x`方向走步。`x`每次的增量为`+-1`，`y`对应的增量为`+-k`。
    </li>
    <li>
        另一种情况是最大位移方向为`y`方向，也就是斜率绝对值大于1的情况。
        这时：`ε`为`|△y|`的倒数，在`y`方向走步。`y`每次的增量为`+-1`，`x`对应的增量为`+-1/k`。
    </li>

<p>
    大家可以发现，在直线生成中，<b>最大位移方向</b>这个概念是十分重要的。
    为什么要这么做呢？大家想想，不管最大位移方向，每次都让`x`走步，来计算`y`会如何呢？
    显然，当斜率大于`1`，甚至很大时，`x`每次才走一步，可是`y`的变化就已经很大了，
    这样画出来的点与点的距离很大，直线看起来就是一系列离散的点，根本没法连成一条直线。
</p>

<p>需要注意的是，由于在光栅化的过程中不可能绘制半个象素点，因此对求出的`x_(i+1)`和`y_(i+1)`的值需进行四舍五入，当然也可以通过加`0.5`再取整的方法实现。</p>
<p>这样一来我们可以得到DDA算法的过程：</p>

<div class='mpCode' node='-1'></div>
<mpWidget>
    <div class='mpCode'  section='0' node='0'></div>
    <div class='mpBuffer' section='0' node='0' authority='readonly'></div>
</mpWidget>

<p>
    总体来看，其实这个算法还是挺简洁的。
</p>
<p>
    在一个迭代算法中，如果每一步的x、y值是用前一步的值加上一个增量来获得的，那么，这种算法就称为<b>增量算法</b>。
    因此，DDA算法是一个增量算法。
</p>
<p>
    DDA算法的优点是：直观、易实现。
    不太理想的地方主要在于：xy坐标与斜率必须要用浮点数表示，而且每一步运算都必须对x或者y进行舍入取整。
    相对于只有整型运算的算法，显然效率并不是太高。
</p>



<h2>Bresenham算法</h2>
<p>...</p>


<?php include $_SERVER['DOCUMENT_ROOT'].'/MinsPipeline/php/articleTemplate_after.php' ?>
<!-- -->